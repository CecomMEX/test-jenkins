name: CI/CD to EC2 via ECR & SSM

on:
  push:
    branches: [ main ]

# Evita despliegues solapados en main
concurrency:
  group: deploy-main
  cancel-in-progress: true

env:
  AWS_REGION: us-east-2
  ACCOUNT_ID: 825765398232
  ECR_REPOSITORY: nestjs-app
  APP_NAME: nestjs-app
  PORT: "3000"
  TARGET_GROUP_ARN: ${{ secrets.TARGET_GROUP_ARN }}

jobs:
  build-push-deploy:
    runs-on: ubuntu-latest
    timeout-minutes: 45

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build image (unique tag + latest)
        id: build
        run: |
          set -euxo pipefail
          UNIQUE_TAG="build-${{ github.run_number }}"
          UNIQUE_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:${UNIQUE_TAG}"
          LATEST_URI="${ACCOUNT_ID}.dkr.ecr.${AWS_REGION}.amazonaws.com/${ECR_REPOSITORY}:latest"

          # Build con tag inmutable
          docker build -t "$UNIQUE_URI" .

          # Etiqueta también como latest
          docker tag "$UNIQUE_URI" "$LATEST_URI"

          echo "UNIQUE_URI=$UNIQUE_URI" >> $GITHUB_ENV
          echo "LATEST_URI=$LATEST_URI" >> $GITHUB_ENV
          echo "UNIQUE_TAG=$UNIQUE_TAG" >> $GITHUB_ENV

      - name: Push image (unique + latest)
        run: |
          set -euxo pipefail
          docker push "$UNIQUE_URI"
          docker push "$LATEST_URI"

      - name: Prepare .env from GitHub Secret (no logs)
        id: envfile
        run: |
          set -euo pipefail
          # No imprimas secretos en logs
          set +x
          printf '%s' "${{ secrets.APP_ENV_FILE }}" > app.env
          set -x
          # Base64 en una sola línea
          ENV_B64=$(base64 -w 0 app.env || base64 app.env | tr -d '\n')
          echo "ENV_B64=$ENV_B64" >> $GITHUB_ENV

      - name: Rolling deploy (ALB + SSM)
        run: |
          set -euxo pipefail

          # Descubre instancias del Target Group
          TARGETS=$(aws elbv2 describe-target-health --target-group-arn "$TARGET_GROUP_ARN" \
                    --query "TargetHealthDescriptions[].Target.Id" --output text || true)

          if [ -z "$TARGETS" ]; then
            echo "No hay instancias registradas en el Target Group."
            exit 1
          fi

          COUNT=$(echo "$TARGETS" | wc -w | tr -d ' ')
          echo "Targets: $TARGETS (count=$COUNT)"

          IMAGE_TO_DEPLOY="$UNIQUE_URI"   # o "$LATEST_URI"

          for IID in $TARGETS; do
            if [ "$COUNT" -gt 1 ]; then
              echo ">> Deregister $IID"
              aws elbv2 deregister-targets --target-group-arn "$TARGET_GROUP_ARN" --targets Id=$IID
              aws elbv2 wait target-deregistered --target-group-arn "$TARGET_GROUP_ARN" --targets Id=$IID || true
            else
              echo ">> 1 instancia: deploy in-place"
            fi

            echo ">> Update unit (IMAGE_URI/PORT) + upload .env + restart via SSM on $IID"
            aws ssm send-command \
              --document-name "AWS-RunShellScript" \
              --instance-ids "$IID" \
              --comment "Deploy ${IMAGE_TO_DEPLOY} + .env" \
              --parameters 'commands=["bash -lc '\''set -euo pipefail; \
                APP='"${APP_NAME}"'; \
                PORT='"${PORT}"'; \
                IMG='"${IMAGE_TO_DEPLOY}"'; \
                ENV_B64='"${ENV_B64}"'; \
                \
                sudo mkdir -p /etc/$APP; \
                echo \"$ENV_B64\" | base64 -d | sudo tee /etc/$APP/$APP.env >/dev/null; \
                sudo chmod 600 /etc/$APP/$APP.env; \
                \
                # Drop-in para forzar --env-file y usar PORT del unit \
                sudo mkdir -p /etc/systemd/system/$APP.service.d; \
                printf \"[Service]\nEnvironmentFile=/etc/$APP/$APP.env\nExecStart=\nExecStart=/usr/bin/docker run --name $APP --pull never --env-file /etc/$APP/$APP.env -p 80:3000 \\$IMAGE_URI\n\" \
                  | sudo tee /etc/systemd/system/$APP.service.d/10-envfile.conf >/dev/null; \
                \
                # Inserta/actualiza IMAGE_URI y PORT en el unit principal \
                if ! grep -q \"^Environment=IMAGE_URI=\" /etc/systemd/system/$APP.service; then \
                  sudo sed -i \"/^\\[Service\\]/a Environment=IMAGE_URI=$IMG\" /etc/systemd/system/$APP.service; \
                else \
                  sudo sed -i \"s|^Environment=IMAGE_URI=.*|Environment=IMAGE_URI=$IMG|\" /etc/systemd/system/$APP.service; \
                fi; \
                if ! grep -q \"^Environment=PORT=\" /etc/systemd/system/$APP.service; then \
                  sudo sed -i \"/^\\[Service\\]/a Environment=PORT=$PORT\" /etc/systemd/system/$APP.service; \
                else \
                  sudo sed -i \"s|^Environment=PORT=.*|Environment=PORT=$PORT|\" /etc/systemd/system/$APP.service; \
                fi; \
                \
                sudo systemctl daemon-reload; \
                sudo systemctl restart $APP.service'\''"]' >/dev/null

            sleep 5

            if [ "$COUNT" -gt 1 ]; then
              echo ">> Re-register $IID"
              aws elbv2 register-targets --target-group-arn "$TARGET_GROUP_ARN" --targets Id=$IID
              aws elbv2 wait target-in-service --target-group-arn "$TARGET_GROUP_ARN" --targets Id=$IID
            fi

            echo ">> $IID actualizado"
          done

      - name: Done
        run: echo "Deploy OK -> ${UNIQUE_URI}"
